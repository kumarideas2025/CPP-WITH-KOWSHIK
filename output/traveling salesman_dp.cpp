#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

// শহরের সংখ্যা, দূরত্বের ম্যাট্রিক্স, এবং মেমোাইজেশনের জন্য DP টেবিল।
// global variable.
int n;
vector<vector<int>> dist;
vector<vector<int>> dp;

// ফাংশনটি সর্বনিম্ন খরচ গণনা করে।
int tsp(int mask, int pos)
{
    // বেস কেস: যদি সব শহর পরিদর্শন করা হয়ে থাকে, তাহলে বর্তমান শহর থেকে শুরুর শহরে ফেরার খরচ রিটার্ন করো।
    if (mask == (1 << n) - 1)
    {
        return dist[pos][0]; //-1 means our journy yet not start.
    }
    // মেমোাইজেশন: যদি এই স্টেটের (মাস্ক এবং পজিশন) জন্য উত্তর আগে থেকেই গণনা করা থাকে, তাহলে সেটি সরাসরি রিটার্ন করো।
    if (dp[mask][pos] != -1)
    {
        return dp[mask][pos];
    }

    int ans = INT_MAX; // সর্বনিম্ন খরচ রাখার জন্য একটি ভেরিয়েবল, যা সর্বোচ্চ মান দিয়ে শুরু করা হয়।

    // সব সম্ভাব্য পরবর্তী শহরগুলো খুঁজে বের করা হয়।
    for (int next = 0; next < n; next++)
    {
        // যদি পরবর্তী শহরটি এখনো পরিদর্শন করা না হয়ে থাকে,
        if ((mask & (1 << next)) == 0)
        {
            // নতুন পথ এবং তার অবশিষ্ট অংশের খরচ গণনা করা হয়।
            int newAns = dist[pos][next] + tsp(mask | (1 << next), next);
            // সর্বনিম্ন খরচ আপডেট করা হয়।
            ans = min(ans, newAns);
        }
    }
    // এই স্টেটের জন্য সর্বনিম্ন খরচ DP টেবিলে সংরক্ষণ করা হয় এবং রিটার্ন করা হয়।
    return dp[mask][pos] = ans;
}

int solve()
{
    // DP টেবিলটি -1 দিয়ে শুরু করা হয়।
    dp.assign(1 << n, vector<int>(n, -1));
    // সমস্যার সমাধান শুরু হয়, যেখানে প্রথম শহর (শহর 0) থেকে যাত্রা শুরু করা হয়।
    return tsp(1, 0);
}

int main()
{
    n = 4; // ৪টি শহর নিয়ে উদাহরণ।
    dist = {
        {0, 10, 15, 20},
        {10, 0, 35, 25},
        {15, 35, 0, 30},
        {20, 25, 30, 0}};

    cout << "The minimum cost of the TSP tour is: " << solve() << endl;

    return 0;
}

// if (mask == (1 << n) - 1) {
//         return dist[pos][0];
//     }
// বিটমাস্ক কী?
// একটি বিটমাস্ক হলো একটি পূর্ণসংখ্যা, যেখানে প্রতিটি বিট (0 বা 1) একটি নির্দিষ্ট অবস্থা বা প্রপার্টিকে প্রতিনিধিত্ব করে।

// উদাহরণস্বরূপ, ৪টি শহরের জন্য TSP সমস্যা সমাধানের সময় আমরা একটি ৪-বিটের পূর্ণসংখ্যাকে মাস্ক হিসেবে ব্যবহার করতে পারি।

// শহর 0: প্রথম বিট

// শহর 1: দ্বিতীয় বিট

// শহর 2: তৃতীয় বিট

// শহর 3: চতুর্থ বিট

// যদি কোনো শহরের সংশ্লিষ্ট বিট 1 হয়, তার মানে সেই শহরটি পরিদর্শন করা হয়েছে। যদি বিট 0 হয়, তার মানে শহরটি এখনো পরিদর্শন করা হয়নি।

// উদাহরণ:

// মাস্ক 1 (0001 বাইনারিতে) মানে শুধুমাত্র শহর 0 পরিদর্শন করা হয়েছে।

// মাস্ক 3 (0011 বাইনারিতে) মানে শহর 0 এবং 1 পরিদর্শন করা হয়েছে।

// মাস্ক 15 (1111 বাইনারিতে) মানে সবকটি শহর পরিদর্শন করা হয়েছে।

// এইভাবে, একটি মাত্র পূর্ণসংখ্যা ব্যবহার করে আমরা খুব সহজে কোন কোন শহর পরিদর্শন করা হয়েছে তার অবস্থা ট্র্যাক করতে পারি।

// int solve() {
// DP টেবিলটি -1 দিয়ে শুরু করা হয়।
//     dp.assign(1 << n, vector<int>(n, -1));
// সমস্যার সমাধান শুরু হয়, যেখানে প্রথম শহর (শহর 0) থেকে যাত্রা শুরু করা হয়।
//     return tsp(1, 0);
// }


//solve ফাংশন: এই ফাংশনটি ডাইনামিক প্রোগ্রামিং এর জন্য প্রয়োজনীয় প্রস্তুতি নেয়।

// এটি dp নামের একটি 2D ভেক্টর তৈরি করে, যা আমাদের মেমোাইজেশন টেবিল। এর আকার হলো (1 << n) x n, অর্থাৎ 2 to the power n.

//   টি সারি এবং n টি কলাম। এটি প্রতিটি সম্ভাব্য অবস্থার (state) জন্য সর্বনিম্ন খরচ সংরক্ষণ করবে।

// টেবিলের প্রতিটি ঘরে -1 দিয়ে পূর্ণ করা হয়, যা বোঝায় যে এখনও কোনো মান গণনা করা হয়নি।

// এরপর এটি মূল রিকার্সিভ ফাংশন tsp(1, 0) কল করে। এখানে 1 (0001 বাইনারি) একটি বিটমাস্ক যা বোঝায় আমরা শহর 0 থেকে যাত্রা শুরু করেছি। 0 হলো আমাদের বর্তমান অবস্থান।